/*
 * Copyright (C) 2021 The "MysteriumNetwork/payments" Authors.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"math/big"
	"sync"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

// EtherClientMock is a mock implementation of EtherClient.
//
// 	func TestSomethingThatUsesEtherClient(t *testing.T) {
//
// 		// make and configure a mocked EtherClient
// 		mockedEtherClient := &EtherClientMock{
// 			BalanceAtFunc: func(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error) {
// 				panic("mock out the BalanceAt method")
// 			},
// 			BlockByHashFunc: func(ctx context.Context, hash common.Hash) (*types.Block, error) {
// 				panic("mock out the BlockByHash method")
// 			},
// 			BlockByNumberFunc: func(ctx context.Context, number *big.Int) (*types.Block, error) {
// 				panic("mock out the BlockByNumber method")
// 			},
// 			BlockNumberFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the BlockNumber method")
// 			},
// 			CallContractFunc: func(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
// 				panic("mock out the CallContract method")
// 			},
// 			ChainIDFunc: func(ctx context.Context) (*big.Int, error) {
// 				panic("mock out the ChainID method")
// 			},
// 			CloseFunc: func()  {
// 				panic("mock out the Close method")
// 			},
// 			CodeAtFunc: func(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error) {
// 				panic("mock out the CodeAt method")
// 			},
// 			EstimateGasFunc: func(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
// 				panic("mock out the EstimateGas method")
// 			},
// 			FilterLogsFunc: func(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
// 				panic("mock out the FilterLogs method")
// 			},
// 			HeaderByHashFunc: func(ctx context.Context, hash common.Hash) (*types.Header, error) {
// 				panic("mock out the HeaderByHash method")
// 			},
// 			HeaderByNumberFunc: func(ctx context.Context, number *big.Int) (*types.Header, error) {
// 				panic("mock out the HeaderByNumber method")
// 			},
// 			NetworkIDFunc: func(ctx context.Context) (*big.Int, error) {
// 				panic("mock out the NetworkID method")
// 			},
// 			NonceAtFunc: func(ctx context.Context, account common.Address, blockNumber *big.Int) (uint64, error) {
// 				panic("mock out the NonceAt method")
// 			},
// 			PendingBalanceAtFunc: func(ctx context.Context, account common.Address) (*big.Int, error) {
// 				panic("mock out the PendingBalanceAt method")
// 			},
// 			PendingCallContractFunc: func(ctx context.Context, msg ethereum.CallMsg) ([]byte, error) {
// 				panic("mock out the PendingCallContract method")
// 			},
// 			PendingCodeAtFunc: func(ctx context.Context, account common.Address) ([]byte, error) {
// 				panic("mock out the PendingCodeAt method")
// 			},
// 			PendingNonceAtFunc: func(ctx context.Context, account common.Address) (uint64, error) {
// 				panic("mock out the PendingNonceAt method")
// 			},
// 			PendingStorageAtFunc: func(ctx context.Context, account common.Address, key common.Hash) ([]byte, error) {
// 				panic("mock out the PendingStorageAt method")
// 			},
// 			PendingTransactionCountFunc: func(ctx context.Context) (uint, error) {
// 				panic("mock out the PendingTransactionCount method")
// 			},
// 			SendTransactionFunc: func(ctx context.Context, tx *types.Transaction) error {
// 				panic("mock out the SendTransaction method")
// 			},
// 			StorageAtFunc: func(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error) {
// 				panic("mock out the StorageAt method")
// 			},
// 			SubscribeFilterLogsFunc: func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error) {
// 				panic("mock out the SubscribeFilterLogs method")
// 			},
// 			SubscribeNewHeadFunc: func(ctx context.Context, ch chan<- *types.Header) (ethereum.Subscription, error) {
// 				panic("mock out the SubscribeNewHead method")
// 			},
// 			SuggestGasPriceFunc: func(ctx context.Context) (*big.Int, error) {
// 				panic("mock out the SuggestGasPrice method")
// 			},
// 			SyncProgressFunc: func(ctx context.Context) (*ethereum.SyncProgress, error) {
// 				panic("mock out the SyncProgress method")
// 			},
// 			TransactionByHashFunc: func(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error) {
// 				panic("mock out the TransactionByHash method")
// 			},
// 			TransactionCountFunc: func(ctx context.Context, blockHash common.Hash) (uint, error) {
// 				panic("mock out the TransactionCount method")
// 			},
// 			TransactionInBlockFunc: func(ctx context.Context, blockHash common.Hash, index uint) (*types.Transaction, error) {
// 				panic("mock out the TransactionInBlock method")
// 			},
// 			TransactionReceiptFunc: func(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
// 				panic("mock out the TransactionReceipt method")
// 			},
// 			TransactionSenderFunc: func(ctx context.Context, tx *types.Transaction, block common.Hash, index uint) (common.Address, error) {
// 				panic("mock out the TransactionSender method")
// 			},
// 		}
//
// 		// use mockedEtherClient in code that requires EtherClient
// 		// and then make assertions.
//
// 	}
type EtherClientMock struct {
	// BalanceAtFunc mocks the BalanceAt method.
	BalanceAtFunc func(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error)

	// BlockByHashFunc mocks the BlockByHash method.
	BlockByHashFunc func(ctx context.Context, hash common.Hash) (*types.Block, error)

	// BlockByNumberFunc mocks the BlockByNumber method.
	BlockByNumberFunc func(ctx context.Context, number *big.Int) (*types.Block, error)

	// BlockNumberFunc mocks the BlockNumber method.
	BlockNumberFunc func(ctx context.Context) (uint64, error)

	// CallContractFunc mocks the CallContract method.
	CallContractFunc func(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error)

	// ChainIDFunc mocks the ChainID method.
	ChainIDFunc func(ctx context.Context) (*big.Int, error)

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CodeAtFunc mocks the CodeAt method.
	CodeAtFunc func(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error)

	// EstimateGasFunc mocks the EstimateGas method.
	EstimateGasFunc func(ctx context.Context, msg ethereum.CallMsg) (uint64, error)

	// FilterLogsFunc mocks the FilterLogs method.
	FilterLogsFunc func(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error)

	// HeaderByHashFunc mocks the HeaderByHash method.
	HeaderByHashFunc func(ctx context.Context, hash common.Hash) (*types.Header, error)

	// HeaderByNumberFunc mocks the HeaderByNumber method.
	HeaderByNumberFunc func(ctx context.Context, number *big.Int) (*types.Header, error)

	// NetworkIDFunc mocks the NetworkID method.
	NetworkIDFunc func(ctx context.Context) (*big.Int, error)

	// NonceAtFunc mocks the NonceAt method.
	NonceAtFunc func(ctx context.Context, account common.Address, blockNumber *big.Int) (uint64, error)

	// PendingBalanceAtFunc mocks the PendingBalanceAt method.
	PendingBalanceAtFunc func(ctx context.Context, account common.Address) (*big.Int, error)

	// PendingCallContractFunc mocks the PendingCallContract method.
	PendingCallContractFunc func(ctx context.Context, msg ethereum.CallMsg) ([]byte, error)

	// PendingCodeAtFunc mocks the PendingCodeAt method.
	PendingCodeAtFunc func(ctx context.Context, account common.Address) ([]byte, error)

	// PendingNonceAtFunc mocks the PendingNonceAt method.
	PendingNonceAtFunc func(ctx context.Context, account common.Address) (uint64, error)

	// PendingStorageAtFunc mocks the PendingStorageAt method.
	PendingStorageAtFunc func(ctx context.Context, account common.Address, key common.Hash) ([]byte, error)

	// PendingTransactionCountFunc mocks the PendingTransactionCount method.
	PendingTransactionCountFunc func(ctx context.Context) (uint, error)

	// SendTransactionFunc mocks the SendTransaction method.
	SendTransactionFunc func(ctx context.Context, tx *types.Transaction) error

	// StorageAtFunc mocks the StorageAt method.
	StorageAtFunc func(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error)

	// SubscribeFilterLogsFunc mocks the SubscribeFilterLogs method.
	SubscribeFilterLogsFunc func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error)

	// SubscribeNewHeadFunc mocks the SubscribeNewHead method.
	SubscribeNewHeadFunc func(ctx context.Context, ch chan<- *types.Header) (ethereum.Subscription, error)

	// SuggestGasPriceFunc mocks the SuggestGasPrice method.
	SuggestGasPriceFunc func(ctx context.Context) (*big.Int, error)

	// SyncProgressFunc mocks the SyncProgress method.
	SyncProgressFunc func(ctx context.Context) (*ethereum.SyncProgress, error)

	// TransactionByHashFunc mocks the TransactionByHash method.
	TransactionByHashFunc func(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error)

	// TransactionCountFunc mocks the TransactionCount method.
	TransactionCountFunc func(ctx context.Context, blockHash common.Hash) (uint, error)

	// TransactionInBlockFunc mocks the TransactionInBlock method.
	TransactionInBlockFunc func(ctx context.Context, blockHash common.Hash, index uint) (*types.Transaction, error)

	// TransactionReceiptFunc mocks the TransactionReceipt method.
	TransactionReceiptFunc func(ctx context.Context, txHash common.Hash) (*types.Receipt, error)

	// TransactionSenderFunc mocks the TransactionSender method.
	TransactionSenderFunc func(ctx context.Context, tx *types.Transaction, block common.Hash, index uint) (common.Address, error)

	// calls tracks calls to the methods.
	calls struct {
		// BalanceAt holds details about calls to the BalanceAt method.
		BalanceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// BlockByHash holds details about calls to the BlockByHash method.
		BlockByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// BlockByNumber holds details about calls to the BlockByNumber method.
		BlockByNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Number is the number argument value.
			Number *big.Int
		}
		// BlockNumber holds details about calls to the BlockNumber method.
		BlockNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CallContract holds details about calls to the CallContract method.
		CallContract []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg ethereum.CallMsg
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// ChainID holds details about calls to the ChainID method.
		ChainID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CodeAt holds details about calls to the CodeAt method.
		CodeAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// EstimateGas holds details about calls to the EstimateGas method.
		EstimateGas []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg ethereum.CallMsg
		}
		// FilterLogs holds details about calls to the FilterLogs method.
		FilterLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q ethereum.FilterQuery
		}
		// HeaderByHash holds details about calls to the HeaderByHash method.
		HeaderByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// HeaderByNumber holds details about calls to the HeaderByNumber method.
		HeaderByNumber []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Number is the number argument value.
			Number *big.Int
		}
		// NetworkID holds details about calls to the NetworkID method.
		NetworkID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NonceAt holds details about calls to the NonceAt method.
		NonceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// PendingBalanceAt holds details about calls to the PendingBalanceAt method.
		PendingBalanceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
		}
		// PendingCallContract holds details about calls to the PendingCallContract method.
		PendingCallContract []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg ethereum.CallMsg
		}
		// PendingCodeAt holds details about calls to the PendingCodeAt method.
		PendingCodeAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
		}
		// PendingNonceAt holds details about calls to the PendingNonceAt method.
		PendingNonceAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
		}
		// PendingStorageAt holds details about calls to the PendingStorageAt method.
		PendingStorageAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// Key is the key argument value.
			Key common.Hash
		}
		// PendingTransactionCount holds details about calls to the PendingTransactionCount method.
		PendingTransactionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SendTransaction holds details about calls to the SendTransaction method.
		SendTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *types.Transaction
		}
		// StorageAt holds details about calls to the StorageAt method.
		StorageAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account common.Address
			// Key is the key argument value.
			Key common.Hash
			// BlockNumber is the blockNumber argument value.
			BlockNumber *big.Int
		}
		// SubscribeFilterLogs holds details about calls to the SubscribeFilterLogs method.
		SubscribeFilterLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q ethereum.FilterQuery
			// Ch is the ch argument value.
			Ch chan<- types.Log
		}
		// SubscribeNewHead holds details about calls to the SubscribeNewHead method.
		SubscribeNewHead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ch is the ch argument value.
			Ch chan<- *types.Header
		}
		// SuggestGasPrice holds details about calls to the SuggestGasPrice method.
		SuggestGasPrice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SyncProgress holds details about calls to the SyncProgress method.
		SyncProgress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// TransactionByHash holds details about calls to the TransactionByHash method.
		TransactionByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// TransactionCount holds details about calls to the TransactionCount method.
		TransactionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash common.Hash
		}
		// TransactionInBlock holds details about calls to the TransactionInBlock method.
		TransactionInBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash common.Hash
			// Index is the index argument value.
			Index uint
		}
		// TransactionReceipt holds details about calls to the TransactionReceipt method.
		TransactionReceipt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxHash is the txHash argument value.
			TxHash common.Hash
		}
		// TransactionSender holds details about calls to the TransactionSender method.
		TransactionSender []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *types.Transaction
			// Block is the block argument value.
			Block common.Hash
			// Index is the index argument value.
			Index uint
		}
	}
	lockBalanceAt               sync.RWMutex
	lockBlockByHash             sync.RWMutex
	lockBlockByNumber           sync.RWMutex
	lockBlockNumber             sync.RWMutex
	lockCallContract            sync.RWMutex
	lockChainID                 sync.RWMutex
	lockClose                   sync.RWMutex
	lockCodeAt                  sync.RWMutex
	lockEstimateGas             sync.RWMutex
	lockFilterLogs              sync.RWMutex
	lockHeaderByHash            sync.RWMutex
	lockHeaderByNumber          sync.RWMutex
	lockNetworkID               sync.RWMutex
	lockNonceAt                 sync.RWMutex
	lockPendingBalanceAt        sync.RWMutex
	lockPendingCallContract     sync.RWMutex
	lockPendingCodeAt           sync.RWMutex
	lockPendingNonceAt          sync.RWMutex
	lockPendingStorageAt        sync.RWMutex
	lockPendingTransactionCount sync.RWMutex
	lockSendTransaction         sync.RWMutex
	lockStorageAt               sync.RWMutex
	lockSubscribeFilterLogs     sync.RWMutex
	lockSubscribeNewHead        sync.RWMutex
	lockSuggestGasPrice         sync.RWMutex
	lockSyncProgress            sync.RWMutex
	lockTransactionByHash       sync.RWMutex
	lockTransactionCount        sync.RWMutex
	lockTransactionInBlock      sync.RWMutex
	lockTransactionReceipt      sync.RWMutex
	lockTransactionSender       sync.RWMutex
}

// BalanceAt calls BalanceAtFunc.
func (mock *EtherClientMock) BalanceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error) {
	if mock.BalanceAtFunc == nil {
		panic("EtherClientMock.BalanceAtFunc: method is nil but EtherClient.BalanceAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		BlockNumber: blockNumber,
	}
	mock.lockBalanceAt.Lock()
	mock.calls.BalanceAt = append(mock.calls.BalanceAt, callInfo)
	mock.lockBalanceAt.Unlock()
	return mock.BalanceAtFunc(ctx, account, blockNumber)
}

// BalanceAtCalls gets all the calls that were made to BalanceAt.
// Check the length with:
//     len(mockedEtherClient.BalanceAtCalls())
func (mock *EtherClientMock) BalanceAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}
	mock.lockBalanceAt.RLock()
	calls = mock.calls.BalanceAt
	mock.lockBalanceAt.RUnlock()
	return calls
}

// BlockByHash calls BlockByHashFunc.
func (mock *EtherClientMock) BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error) {
	if mock.BlockByHashFunc == nil {
		panic("EtherClientMock.BlockByHashFunc: method is nil but EtherClient.BlockByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash common.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockByHash.Lock()
	mock.calls.BlockByHash = append(mock.calls.BlockByHash, callInfo)
	mock.lockBlockByHash.Unlock()
	return mock.BlockByHashFunc(ctx, hash)
}

// BlockByHashCalls gets all the calls that were made to BlockByHash.
// Check the length with:
//     len(mockedEtherClient.BlockByHashCalls())
func (mock *EtherClientMock) BlockByHashCalls() []struct {
	Ctx  context.Context
	Hash common.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash common.Hash
	}
	mock.lockBlockByHash.RLock()
	calls = mock.calls.BlockByHash
	mock.lockBlockByHash.RUnlock()
	return calls
}

// BlockByNumber calls BlockByNumberFunc.
func (mock *EtherClientMock) BlockByNumber(ctx context.Context, number *big.Int) (*types.Block, error) {
	if mock.BlockByNumberFunc == nil {
		panic("EtherClientMock.BlockByNumberFunc: method is nil but EtherClient.BlockByNumber was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Number *big.Int
	}{
		Ctx:    ctx,
		Number: number,
	}
	mock.lockBlockByNumber.Lock()
	mock.calls.BlockByNumber = append(mock.calls.BlockByNumber, callInfo)
	mock.lockBlockByNumber.Unlock()
	return mock.BlockByNumberFunc(ctx, number)
}

// BlockByNumberCalls gets all the calls that were made to BlockByNumber.
// Check the length with:
//     len(mockedEtherClient.BlockByNumberCalls())
func (mock *EtherClientMock) BlockByNumberCalls() []struct {
	Ctx    context.Context
	Number *big.Int
} {
	var calls []struct {
		Ctx    context.Context
		Number *big.Int
	}
	mock.lockBlockByNumber.RLock()
	calls = mock.calls.BlockByNumber
	mock.lockBlockByNumber.RUnlock()
	return calls
}

// BlockNumber calls BlockNumberFunc.
func (mock *EtherClientMock) BlockNumber(ctx context.Context) (uint64, error) {
	if mock.BlockNumberFunc == nil {
		panic("EtherClientMock.BlockNumberFunc: method is nil but EtherClient.BlockNumber was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBlockNumber.Lock()
	mock.calls.BlockNumber = append(mock.calls.BlockNumber, callInfo)
	mock.lockBlockNumber.Unlock()
	return mock.BlockNumberFunc(ctx)
}

// BlockNumberCalls gets all the calls that were made to BlockNumber.
// Check the length with:
//     len(mockedEtherClient.BlockNumberCalls())
func (mock *EtherClientMock) BlockNumberCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBlockNumber.RLock()
	calls = mock.calls.BlockNumber
	mock.lockBlockNumber.RUnlock()
	return calls
}

// CallContract calls CallContractFunc.
func (mock *EtherClientMock) CallContract(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
	if mock.CallContractFunc == nil {
		panic("EtherClientMock.CallContractFunc: method is nil but EtherClient.CallContract was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Msg         ethereum.CallMsg
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Msg:         msg,
		BlockNumber: blockNumber,
	}
	mock.lockCallContract.Lock()
	mock.calls.CallContract = append(mock.calls.CallContract, callInfo)
	mock.lockCallContract.Unlock()
	return mock.CallContractFunc(ctx, msg, blockNumber)
}

// CallContractCalls gets all the calls that were made to CallContract.
// Check the length with:
//     len(mockedEtherClient.CallContractCalls())
func (mock *EtherClientMock) CallContractCalls() []struct {
	Ctx         context.Context
	Msg         ethereum.CallMsg
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Msg         ethereum.CallMsg
		BlockNumber *big.Int
	}
	mock.lockCallContract.RLock()
	calls = mock.calls.CallContract
	mock.lockCallContract.RUnlock()
	return calls
}

// ChainID calls ChainIDFunc.
func (mock *EtherClientMock) ChainID(ctx context.Context) (*big.Int, error) {
	if mock.ChainIDFunc == nil {
		panic("EtherClientMock.ChainIDFunc: method is nil but EtherClient.ChainID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainID.Lock()
	mock.calls.ChainID = append(mock.calls.ChainID, callInfo)
	mock.lockChainID.Unlock()
	return mock.ChainIDFunc(ctx)
}

// ChainIDCalls gets all the calls that were made to ChainID.
// Check the length with:
//     len(mockedEtherClient.ChainIDCalls())
func (mock *EtherClientMock) ChainIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainID.RLock()
	calls = mock.calls.ChainID
	mock.lockChainID.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *EtherClientMock) Close() {
	if mock.CloseFunc == nil {
		panic("EtherClientMock.CloseFunc: method is nil but EtherClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedEtherClient.CloseCalls())
func (mock *EtherClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CodeAt calls CodeAtFunc.
func (mock *EtherClientMock) CodeAt(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error) {
	if mock.CodeAtFunc == nil {
		panic("EtherClientMock.CodeAtFunc: method is nil but EtherClient.CodeAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		BlockNumber: blockNumber,
	}
	mock.lockCodeAt.Lock()
	mock.calls.CodeAt = append(mock.calls.CodeAt, callInfo)
	mock.lockCodeAt.Unlock()
	return mock.CodeAtFunc(ctx, account, blockNumber)
}

// CodeAtCalls gets all the calls that were made to CodeAt.
// Check the length with:
//     len(mockedEtherClient.CodeAtCalls())
func (mock *EtherClientMock) CodeAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}
	mock.lockCodeAt.RLock()
	calls = mock.calls.CodeAt
	mock.lockCodeAt.RUnlock()
	return calls
}

// EstimateGas calls EstimateGasFunc.
func (mock *EtherClientMock) EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
	if mock.EstimateGasFunc == nil {
		panic("EtherClientMock.EstimateGasFunc: method is nil but EtherClient.EstimateGas was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockEstimateGas.Lock()
	mock.calls.EstimateGas = append(mock.calls.EstimateGas, callInfo)
	mock.lockEstimateGas.Unlock()
	return mock.EstimateGasFunc(ctx, msg)
}

// EstimateGasCalls gets all the calls that were made to EstimateGas.
// Check the length with:
//     len(mockedEtherClient.EstimateGasCalls())
func (mock *EtherClientMock) EstimateGasCalls() []struct {
	Ctx context.Context
	Msg ethereum.CallMsg
} {
	var calls []struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}
	mock.lockEstimateGas.RLock()
	calls = mock.calls.EstimateGas
	mock.lockEstimateGas.RUnlock()
	return calls
}

// FilterLogs calls FilterLogsFunc.
func (mock *EtherClientMock) FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
	if mock.FilterLogsFunc == nil {
		panic("EtherClientMock.FilterLogsFunc: method is nil but EtherClient.FilterLogs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockFilterLogs.Lock()
	mock.calls.FilterLogs = append(mock.calls.FilterLogs, callInfo)
	mock.lockFilterLogs.Unlock()
	return mock.FilterLogsFunc(ctx, q)
}

// FilterLogsCalls gets all the calls that were made to FilterLogs.
// Check the length with:
//     len(mockedEtherClient.FilterLogsCalls())
func (mock *EtherClientMock) FilterLogsCalls() []struct {
	Ctx context.Context
	Q   ethereum.FilterQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
	}
	mock.lockFilterLogs.RLock()
	calls = mock.calls.FilterLogs
	mock.lockFilterLogs.RUnlock()
	return calls
}

// HeaderByHash calls HeaderByHashFunc.
func (mock *EtherClientMock) HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error) {
	if mock.HeaderByHashFunc == nil {
		panic("EtherClientMock.HeaderByHashFunc: method is nil but EtherClient.HeaderByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash common.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockHeaderByHash.Lock()
	mock.calls.HeaderByHash = append(mock.calls.HeaderByHash, callInfo)
	mock.lockHeaderByHash.Unlock()
	return mock.HeaderByHashFunc(ctx, hash)
}

// HeaderByHashCalls gets all the calls that were made to HeaderByHash.
// Check the length with:
//     len(mockedEtherClient.HeaderByHashCalls())
func (mock *EtherClientMock) HeaderByHashCalls() []struct {
	Ctx  context.Context
	Hash common.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash common.Hash
	}
	mock.lockHeaderByHash.RLock()
	calls = mock.calls.HeaderByHash
	mock.lockHeaderByHash.RUnlock()
	return calls
}

// HeaderByNumber calls HeaderByNumberFunc.
func (mock *EtherClientMock) HeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error) {
	if mock.HeaderByNumberFunc == nil {
		panic("EtherClientMock.HeaderByNumberFunc: method is nil but EtherClient.HeaderByNumber was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Number *big.Int
	}{
		Ctx:    ctx,
		Number: number,
	}
	mock.lockHeaderByNumber.Lock()
	mock.calls.HeaderByNumber = append(mock.calls.HeaderByNumber, callInfo)
	mock.lockHeaderByNumber.Unlock()
	return mock.HeaderByNumberFunc(ctx, number)
}

// HeaderByNumberCalls gets all the calls that were made to HeaderByNumber.
// Check the length with:
//     len(mockedEtherClient.HeaderByNumberCalls())
func (mock *EtherClientMock) HeaderByNumberCalls() []struct {
	Ctx    context.Context
	Number *big.Int
} {
	var calls []struct {
		Ctx    context.Context
		Number *big.Int
	}
	mock.lockHeaderByNumber.RLock()
	calls = mock.calls.HeaderByNumber
	mock.lockHeaderByNumber.RUnlock()
	return calls
}

// NetworkID calls NetworkIDFunc.
func (mock *EtherClientMock) NetworkID(ctx context.Context) (*big.Int, error) {
	if mock.NetworkIDFunc == nil {
		panic("EtherClientMock.NetworkIDFunc: method is nil but EtherClient.NetworkID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNetworkID.Lock()
	mock.calls.NetworkID = append(mock.calls.NetworkID, callInfo)
	mock.lockNetworkID.Unlock()
	return mock.NetworkIDFunc(ctx)
}

// NetworkIDCalls gets all the calls that were made to NetworkID.
// Check the length with:
//     len(mockedEtherClient.NetworkIDCalls())
func (mock *EtherClientMock) NetworkIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNetworkID.RLock()
	calls = mock.calls.NetworkID
	mock.lockNetworkID.RUnlock()
	return calls
}

// NonceAt calls NonceAtFunc.
func (mock *EtherClientMock) NonceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (uint64, error) {
	if mock.NonceAtFunc == nil {
		panic("EtherClientMock.NonceAtFunc: method is nil but EtherClient.NonceAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		BlockNumber: blockNumber,
	}
	mock.lockNonceAt.Lock()
	mock.calls.NonceAt = append(mock.calls.NonceAt, callInfo)
	mock.lockNonceAt.Unlock()
	return mock.NonceAtFunc(ctx, account, blockNumber)
}

// NonceAtCalls gets all the calls that were made to NonceAt.
// Check the length with:
//     len(mockedEtherClient.NonceAtCalls())
func (mock *EtherClientMock) NonceAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		BlockNumber *big.Int
	}
	mock.lockNonceAt.RLock()
	calls = mock.calls.NonceAt
	mock.lockNonceAt.RUnlock()
	return calls
}

// PendingBalanceAt calls PendingBalanceAtFunc.
func (mock *EtherClientMock) PendingBalanceAt(ctx context.Context, account common.Address) (*big.Int, error) {
	if mock.PendingBalanceAtFunc == nil {
		panic("EtherClientMock.PendingBalanceAtFunc: method is nil but EtherClient.PendingBalanceAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockPendingBalanceAt.Lock()
	mock.calls.PendingBalanceAt = append(mock.calls.PendingBalanceAt, callInfo)
	mock.lockPendingBalanceAt.Unlock()
	return mock.PendingBalanceAtFunc(ctx, account)
}

// PendingBalanceAtCalls gets all the calls that were made to PendingBalanceAt.
// Check the length with:
//     len(mockedEtherClient.PendingBalanceAtCalls())
func (mock *EtherClientMock) PendingBalanceAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
	}
	mock.lockPendingBalanceAt.RLock()
	calls = mock.calls.PendingBalanceAt
	mock.lockPendingBalanceAt.RUnlock()
	return calls
}

// PendingCallContract calls PendingCallContractFunc.
func (mock *EtherClientMock) PendingCallContract(ctx context.Context, msg ethereum.CallMsg) ([]byte, error) {
	if mock.PendingCallContractFunc == nil {
		panic("EtherClientMock.PendingCallContractFunc: method is nil but EtherClient.PendingCallContract was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPendingCallContract.Lock()
	mock.calls.PendingCallContract = append(mock.calls.PendingCallContract, callInfo)
	mock.lockPendingCallContract.Unlock()
	return mock.PendingCallContractFunc(ctx, msg)
}

// PendingCallContractCalls gets all the calls that were made to PendingCallContract.
// Check the length with:
//     len(mockedEtherClient.PendingCallContractCalls())
func (mock *EtherClientMock) PendingCallContractCalls() []struct {
	Ctx context.Context
	Msg ethereum.CallMsg
} {
	var calls []struct {
		Ctx context.Context
		Msg ethereum.CallMsg
	}
	mock.lockPendingCallContract.RLock()
	calls = mock.calls.PendingCallContract
	mock.lockPendingCallContract.RUnlock()
	return calls
}

// PendingCodeAt calls PendingCodeAtFunc.
func (mock *EtherClientMock) PendingCodeAt(ctx context.Context, account common.Address) ([]byte, error) {
	if mock.PendingCodeAtFunc == nil {
		panic("EtherClientMock.PendingCodeAtFunc: method is nil but EtherClient.PendingCodeAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockPendingCodeAt.Lock()
	mock.calls.PendingCodeAt = append(mock.calls.PendingCodeAt, callInfo)
	mock.lockPendingCodeAt.Unlock()
	return mock.PendingCodeAtFunc(ctx, account)
}

// PendingCodeAtCalls gets all the calls that were made to PendingCodeAt.
// Check the length with:
//     len(mockedEtherClient.PendingCodeAtCalls())
func (mock *EtherClientMock) PendingCodeAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
	}
	mock.lockPendingCodeAt.RLock()
	calls = mock.calls.PendingCodeAt
	mock.lockPendingCodeAt.RUnlock()
	return calls
}

// PendingNonceAt calls PendingNonceAtFunc.
func (mock *EtherClientMock) PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) {
	if mock.PendingNonceAtFunc == nil {
		panic("EtherClientMock.PendingNonceAtFunc: method is nil but EtherClient.PendingNonceAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockPendingNonceAt.Lock()
	mock.calls.PendingNonceAt = append(mock.calls.PendingNonceAt, callInfo)
	mock.lockPendingNonceAt.Unlock()
	return mock.PendingNonceAtFunc(ctx, account)
}

// PendingNonceAtCalls gets all the calls that were made to PendingNonceAt.
// Check the length with:
//     len(mockedEtherClient.PendingNonceAtCalls())
func (mock *EtherClientMock) PendingNonceAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
	}
	mock.lockPendingNonceAt.RLock()
	calls = mock.calls.PendingNonceAt
	mock.lockPendingNonceAt.RUnlock()
	return calls
}

// PendingStorageAt calls PendingStorageAtFunc.
func (mock *EtherClientMock) PendingStorageAt(ctx context.Context, account common.Address, key common.Hash) ([]byte, error) {
	if mock.PendingStorageAtFunc == nil {
		panic("EtherClientMock.PendingStorageAtFunc: method is nil but EtherClient.PendingStorageAt was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account common.Address
		Key     common.Hash
	}{
		Ctx:     ctx,
		Account: account,
		Key:     key,
	}
	mock.lockPendingStorageAt.Lock()
	mock.calls.PendingStorageAt = append(mock.calls.PendingStorageAt, callInfo)
	mock.lockPendingStorageAt.Unlock()
	return mock.PendingStorageAtFunc(ctx, account, key)
}

// PendingStorageAtCalls gets all the calls that were made to PendingStorageAt.
// Check the length with:
//     len(mockedEtherClient.PendingStorageAtCalls())
func (mock *EtherClientMock) PendingStorageAtCalls() []struct {
	Ctx     context.Context
	Account common.Address
	Key     common.Hash
} {
	var calls []struct {
		Ctx     context.Context
		Account common.Address
		Key     common.Hash
	}
	mock.lockPendingStorageAt.RLock()
	calls = mock.calls.PendingStorageAt
	mock.lockPendingStorageAt.RUnlock()
	return calls
}

// PendingTransactionCount calls PendingTransactionCountFunc.
func (mock *EtherClientMock) PendingTransactionCount(ctx context.Context) (uint, error) {
	if mock.PendingTransactionCountFunc == nil {
		panic("EtherClientMock.PendingTransactionCountFunc: method is nil but EtherClient.PendingTransactionCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPendingTransactionCount.Lock()
	mock.calls.PendingTransactionCount = append(mock.calls.PendingTransactionCount, callInfo)
	mock.lockPendingTransactionCount.Unlock()
	return mock.PendingTransactionCountFunc(ctx)
}

// PendingTransactionCountCalls gets all the calls that were made to PendingTransactionCount.
// Check the length with:
//     len(mockedEtherClient.PendingTransactionCountCalls())
func (mock *EtherClientMock) PendingTransactionCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPendingTransactionCount.RLock()
	calls = mock.calls.PendingTransactionCount
	mock.lockPendingTransactionCount.RUnlock()
	return calls
}

// SendTransaction calls SendTransactionFunc.
func (mock *EtherClientMock) SendTransaction(ctx context.Context, tx *types.Transaction) error {
	if mock.SendTransactionFunc == nil {
		panic("EtherClientMock.SendTransactionFunc: method is nil but EtherClient.SendTransaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tx  *types.Transaction
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSendTransaction.Lock()
	mock.calls.SendTransaction = append(mock.calls.SendTransaction, callInfo)
	mock.lockSendTransaction.Unlock()
	return mock.SendTransactionFunc(ctx, tx)
}

// SendTransactionCalls gets all the calls that were made to SendTransaction.
// Check the length with:
//     len(mockedEtherClient.SendTransactionCalls())
func (mock *EtherClientMock) SendTransactionCalls() []struct {
	Ctx context.Context
	Tx  *types.Transaction
} {
	var calls []struct {
		Ctx context.Context
		Tx  *types.Transaction
	}
	mock.lockSendTransaction.RLock()
	calls = mock.calls.SendTransaction
	mock.lockSendTransaction.RUnlock()
	return calls
}

// StorageAt calls StorageAtFunc.
func (mock *EtherClientMock) StorageAt(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error) {
	if mock.StorageAtFunc == nil {
		panic("EtherClientMock.StorageAtFunc: method is nil but EtherClient.StorageAt was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Account     common.Address
		Key         common.Hash
		BlockNumber *big.Int
	}{
		Ctx:         ctx,
		Account:     account,
		Key:         key,
		BlockNumber: blockNumber,
	}
	mock.lockStorageAt.Lock()
	mock.calls.StorageAt = append(mock.calls.StorageAt, callInfo)
	mock.lockStorageAt.Unlock()
	return mock.StorageAtFunc(ctx, account, key, blockNumber)
}

// StorageAtCalls gets all the calls that were made to StorageAt.
// Check the length with:
//     len(mockedEtherClient.StorageAtCalls())
func (mock *EtherClientMock) StorageAtCalls() []struct {
	Ctx         context.Context
	Account     common.Address
	Key         common.Hash
	BlockNumber *big.Int
} {
	var calls []struct {
		Ctx         context.Context
		Account     common.Address
		Key         common.Hash
		BlockNumber *big.Int
	}
	mock.lockStorageAt.RLock()
	calls = mock.calls.StorageAt
	mock.lockStorageAt.RUnlock()
	return calls
}

// SubscribeFilterLogs calls SubscribeFilterLogsFunc.
func (mock *EtherClientMock) SubscribeFilterLogs(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error) {
	if mock.SubscribeFilterLogsFunc == nil {
		panic("EtherClientMock.SubscribeFilterLogsFunc: method is nil but EtherClient.SubscribeFilterLogs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
		Ch  chan<- types.Log
	}{
		Ctx: ctx,
		Q:   q,
		Ch:  ch,
	}
	mock.lockSubscribeFilterLogs.Lock()
	mock.calls.SubscribeFilterLogs = append(mock.calls.SubscribeFilterLogs, callInfo)
	mock.lockSubscribeFilterLogs.Unlock()
	return mock.SubscribeFilterLogsFunc(ctx, q, ch)
}

// SubscribeFilterLogsCalls gets all the calls that were made to SubscribeFilterLogs.
// Check the length with:
//     len(mockedEtherClient.SubscribeFilterLogsCalls())
func (mock *EtherClientMock) SubscribeFilterLogsCalls() []struct {
	Ctx context.Context
	Q   ethereum.FilterQuery
	Ch  chan<- types.Log
} {
	var calls []struct {
		Ctx context.Context
		Q   ethereum.FilterQuery
		Ch  chan<- types.Log
	}
	mock.lockSubscribeFilterLogs.RLock()
	calls = mock.calls.SubscribeFilterLogs
	mock.lockSubscribeFilterLogs.RUnlock()
	return calls
}

// SubscribeNewHead calls SubscribeNewHeadFunc.
func (mock *EtherClientMock) SubscribeNewHead(ctx context.Context, ch chan<- *types.Header) (ethereum.Subscription, error) {
	if mock.SubscribeNewHeadFunc == nil {
		panic("EtherClientMock.SubscribeNewHeadFunc: method is nil but EtherClient.SubscribeNewHead was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ch  chan<- *types.Header
	}{
		Ctx: ctx,
		Ch:  ch,
	}
	mock.lockSubscribeNewHead.Lock()
	mock.calls.SubscribeNewHead = append(mock.calls.SubscribeNewHead, callInfo)
	mock.lockSubscribeNewHead.Unlock()
	return mock.SubscribeNewHeadFunc(ctx, ch)
}

// SubscribeNewHeadCalls gets all the calls that were made to SubscribeNewHead.
// Check the length with:
//     len(mockedEtherClient.SubscribeNewHeadCalls())
func (mock *EtherClientMock) SubscribeNewHeadCalls() []struct {
	Ctx context.Context
	Ch  chan<- *types.Header
} {
	var calls []struct {
		Ctx context.Context
		Ch  chan<- *types.Header
	}
	mock.lockSubscribeNewHead.RLock()
	calls = mock.calls.SubscribeNewHead
	mock.lockSubscribeNewHead.RUnlock()
	return calls
}

// SuggestGasPrice calls SuggestGasPriceFunc.
func (mock *EtherClientMock) SuggestGasPrice(ctx context.Context) (*big.Int, error) {
	if mock.SuggestGasPriceFunc == nil {
		panic("EtherClientMock.SuggestGasPriceFunc: method is nil but EtherClient.SuggestGasPrice was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSuggestGasPrice.Lock()
	mock.calls.SuggestGasPrice = append(mock.calls.SuggestGasPrice, callInfo)
	mock.lockSuggestGasPrice.Unlock()
	return mock.SuggestGasPriceFunc(ctx)
}

// SuggestGasPriceCalls gets all the calls that were made to SuggestGasPrice.
// Check the length with:
//     len(mockedEtherClient.SuggestGasPriceCalls())
func (mock *EtherClientMock) SuggestGasPriceCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSuggestGasPrice.RLock()
	calls = mock.calls.SuggestGasPrice
	mock.lockSuggestGasPrice.RUnlock()
	return calls
}

// SyncProgress calls SyncProgressFunc.
func (mock *EtherClientMock) SyncProgress(ctx context.Context) (*ethereum.SyncProgress, error) {
	if mock.SyncProgressFunc == nil {
		panic("EtherClientMock.SyncProgressFunc: method is nil but EtherClient.SyncProgress was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSyncProgress.Lock()
	mock.calls.SyncProgress = append(mock.calls.SyncProgress, callInfo)
	mock.lockSyncProgress.Unlock()
	return mock.SyncProgressFunc(ctx)
}

// SyncProgressCalls gets all the calls that were made to SyncProgress.
// Check the length with:
//     len(mockedEtherClient.SyncProgressCalls())
func (mock *EtherClientMock) SyncProgressCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSyncProgress.RLock()
	calls = mock.calls.SyncProgress
	mock.lockSyncProgress.RUnlock()
	return calls
}

// TransactionByHash calls TransactionByHashFunc.
func (mock *EtherClientMock) TransactionByHash(ctx context.Context, hash common.Hash) (*types.Transaction, bool, error) {
	if mock.TransactionByHashFunc == nil {
		panic("EtherClientMock.TransactionByHashFunc: method is nil but EtherClient.TransactionByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash common.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockTransactionByHash.Lock()
	mock.calls.TransactionByHash = append(mock.calls.TransactionByHash, callInfo)
	mock.lockTransactionByHash.Unlock()
	return mock.TransactionByHashFunc(ctx, hash)
}

// TransactionByHashCalls gets all the calls that were made to TransactionByHash.
// Check the length with:
//     len(mockedEtherClient.TransactionByHashCalls())
func (mock *EtherClientMock) TransactionByHashCalls() []struct {
	Ctx  context.Context
	Hash common.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash common.Hash
	}
	mock.lockTransactionByHash.RLock()
	calls = mock.calls.TransactionByHash
	mock.lockTransactionByHash.RUnlock()
	return calls
}

// TransactionCount calls TransactionCountFunc.
func (mock *EtherClientMock) TransactionCount(ctx context.Context, blockHash common.Hash) (uint, error) {
	if mock.TransactionCountFunc == nil {
		panic("EtherClientMock.TransactionCountFunc: method is nil but EtherClient.TransactionCount was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash common.Hash
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
	}
	mock.lockTransactionCount.Lock()
	mock.calls.TransactionCount = append(mock.calls.TransactionCount, callInfo)
	mock.lockTransactionCount.Unlock()
	return mock.TransactionCountFunc(ctx, blockHash)
}

// TransactionCountCalls gets all the calls that were made to TransactionCount.
// Check the length with:
//     len(mockedEtherClient.TransactionCountCalls())
func (mock *EtherClientMock) TransactionCountCalls() []struct {
	Ctx       context.Context
	BlockHash common.Hash
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash common.Hash
	}
	mock.lockTransactionCount.RLock()
	calls = mock.calls.TransactionCount
	mock.lockTransactionCount.RUnlock()
	return calls
}

// TransactionInBlock calls TransactionInBlockFunc.
func (mock *EtherClientMock) TransactionInBlock(ctx context.Context, blockHash common.Hash, index uint) (*types.Transaction, error) {
	if mock.TransactionInBlockFunc == nil {
		panic("EtherClientMock.TransactionInBlockFunc: method is nil but EtherClient.TransactionInBlock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash common.Hash
		Index     uint
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
		Index:     index,
	}
	mock.lockTransactionInBlock.Lock()
	mock.calls.TransactionInBlock = append(mock.calls.TransactionInBlock, callInfo)
	mock.lockTransactionInBlock.Unlock()
	return mock.TransactionInBlockFunc(ctx, blockHash, index)
}

// TransactionInBlockCalls gets all the calls that were made to TransactionInBlock.
// Check the length with:
//     len(mockedEtherClient.TransactionInBlockCalls())
func (mock *EtherClientMock) TransactionInBlockCalls() []struct {
	Ctx       context.Context
	BlockHash common.Hash
	Index     uint
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash common.Hash
		Index     uint
	}
	mock.lockTransactionInBlock.RLock()
	calls = mock.calls.TransactionInBlock
	mock.lockTransactionInBlock.RUnlock()
	return calls
}

// TransactionReceipt calls TransactionReceiptFunc.
func (mock *EtherClientMock) TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
	if mock.TransactionReceiptFunc == nil {
		panic("EtherClientMock.TransactionReceiptFunc: method is nil but EtherClient.TransactionReceipt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TxHash common.Hash
	}{
		Ctx:    ctx,
		TxHash: txHash,
	}
	mock.lockTransactionReceipt.Lock()
	mock.calls.TransactionReceipt = append(mock.calls.TransactionReceipt, callInfo)
	mock.lockTransactionReceipt.Unlock()
	return mock.TransactionReceiptFunc(ctx, txHash)
}

// TransactionReceiptCalls gets all the calls that were made to TransactionReceipt.
// Check the length with:
//     len(mockedEtherClient.TransactionReceiptCalls())
func (mock *EtherClientMock) TransactionReceiptCalls() []struct {
	Ctx    context.Context
	TxHash common.Hash
} {
	var calls []struct {
		Ctx    context.Context
		TxHash common.Hash
	}
	mock.lockTransactionReceipt.RLock()
	calls = mock.calls.TransactionReceipt
	mock.lockTransactionReceipt.RUnlock()
	return calls
}

// TransactionSender calls TransactionSenderFunc.
func (mock *EtherClientMock) TransactionSender(ctx context.Context, tx *types.Transaction, block common.Hash, index uint) (common.Address, error) {
	if mock.TransactionSenderFunc == nil {
		panic("EtherClientMock.TransactionSenderFunc: method is nil but EtherClient.TransactionSender was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Tx    *types.Transaction
		Block common.Hash
		Index uint
	}{
		Ctx:   ctx,
		Tx:    tx,
		Block: block,
		Index: index,
	}
	mock.lockTransactionSender.Lock()
	mock.calls.TransactionSender = append(mock.calls.TransactionSender, callInfo)
	mock.lockTransactionSender.Unlock()
	return mock.TransactionSenderFunc(ctx, tx, block, index)
}

// TransactionSenderCalls gets all the calls that were made to TransactionSender.
// Check the length with:
//     len(mockedEtherClient.TransactionSenderCalls())
func (mock *EtherClientMock) TransactionSenderCalls() []struct {
	Ctx   context.Context
	Tx    *types.Transaction
	Block common.Hash
	Index uint
} {
	var calls []struct {
		Ctx   context.Context
		Tx    *types.Transaction
		Block common.Hash
		Index uint
	}
	mock.lockTransactionSender.RLock()
	calls = mock.calls.TransactionSender
	mock.lockTransactionSender.RUnlock()
	return calls
}
